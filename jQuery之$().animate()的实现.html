<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>jQuery之$().animate()的实现</title>
</head>
<body>

  <div id="A" style="width:100px;height:50px;background-color: deeppink">这是A</div>

<script>
  // (function(a){
  //   console.log(a) //name
  // })('name')
  //
  // (function (b) {
  //   console.log(b) //function(){console.log('name')}
  // })(function () {
  //   console.log('name')
  // })


  //匿名函数自调用，下面好长好长的function就是$
  //也就是说$是一个function(){xxx}
  (function($) {

    window.$ = $;

  })(
    //这里也是匿名函数自调用
    //本质就是经过一系列操作得到chenQuery并作为参数$，赋值给window.$
    function() {
    //匹配ID
    let rquickExpr = /^(?:#([\w-]*))$/;
    //jQuery初始化
    function chenQuery(selector) {
      return new chenQuery.fn.init(selector);
    }

    function getStyles(elem) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }

    function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }

    //============================================================


      //创建动画缓动对象//
      function Tween(value, prop, animation) {
        this.elem=animation.elem;
        this.prop=prop;
        this.easing= "swing"; //动画缓动算法
        this.options=animation.options;
        //获取初始值
        this.start=this.now = this.get();
        //动画最终值
        this.end= value;
        //单位
        this.unit="px"
      }

      Tween.prototype = {
        //获取元素的当前属性
        get: function() {
          let computed = getStyles(this.elem);
          let ret = computed.getPropertyValue(this.prop) || computed[this.prop];
          return parseFloat(ret);
        },
        //运行动画
        run:function(percent){
          let eased
          //根据缓动算法改变percent
          this.pos = eased = swing(percent);
          //获取具体的改变坐标值
          this.now = (this.end - this.start) * eased + this.start;
          //最终改变坐标
          this.elem.style[this.prop] = this.now + "px";
          return this;
        }
      }

      //创建开始时间
      function createFxNow() {
        setTimeout(function() {
          Animation.fxNow = undefined;
        });
        return (Animation.fxNow = Date.now());
      }

      let inProgress
      function schedule() {
        //inProgress是判断整个动画流程是否结束的标志
        //当inProgress=null时，整个动画结束
        if ( inProgress ) {
          //走这边
          //使用requestAnimationFrame来完成动画
          //递归
          window.requestAnimationFrame( schedule );
          /*执行动画*/
          Animation.fx.tick();
        }

      }


      // 动画类
      // element, options, optall,func
      function Animation(elem, options, optall,func,){
        //动画对象
        let animation = {
          elem:elem,
          props:options,
          originalOptions:optall,
          options:optall,
          startTime:Animation.fxNow || createFxNow(),//动画开始时间
          tweens:[] //存放每个属性的缓动对象，用于动画
        }
        //生成属性对应的动画算法对象
        for (let k in options) {
          // tweens保存每一个属性对应的缓动控制对象
          animation.tweens.push( new Tween(options[k], k, animation) )
        }

        //动画状态
        let stopped;
        //动画的定时器调用包装器
        let tick = function() {
          if (stopped) {
            return false;
          }
          //动画时间算法
          let currentTime = Animation.fxNow || createFxNow,
            //运动时间递减
            remaining = Math.max(0, animation.startTime + animation.options.duration - currentTime),
            temp = remaining / animation.options.duration || 0,
            percent = 1 - temp;

          let index = 0,
            length = animation.tweens.length;
          //执行动画改变
          for (; index < length; index++) {
            //percent改变值
            animation.tweens[index].run(percent);
          }
          //当进度不到100%时，继续绘制动画
          if (percent < 1 && length) {

            return remaining;
          }


          tick.complete()
          return false
        }
        tick.elem = elem;
        tick.anim = animation
        tick.complete = func

        Animation.fx.timer(tick)
      }

      //用于requestAnimationFrame调用
      Animation.timers =[]

      Animation.fx = {
        //开始动画队列
        //Animation.tick()
        timer: function(timer,) {
          Animation.timers.push(timer);
          if (timer()) {
            //开始执行动画
            Animation.fx.start();
          // func()
          }
            // else {
          //   Animation.timers.pop();
          // }
        },
        //开始循环
        start: function(func) {
          if ( inProgress ) {
            return;
          }
          //动画开始即为运行中，加上锁
          inProgress = true;
          //运行
          schedule();
          // func()
        },
        //停止循环
        stop:function(){
          inProgress = null;
        },
        //循环的的检测
        tick: function() {
          var timer,
            i = 0,
            timers = Animation.timers;

          Animation.fxNow = Date.now();
          for (; i < timers.length; i++) {
            timer = timers[i];

            if (!timer() && timers[i] === timer) {

              //如果完成了就删除这个动画
              timers.splice(i--, 1);
              console.log(timers,'timer207')

            }
          }
          if (!timers.length) {
            Animation.fx.stop();
          }
          Animation.fxNow = undefined;
        }
      }
    //============================================================
    /*动画*/
    let animation = (function() {
      let self = {};
      let Queue = []; //动画队列
      let firing = false //动画锁
      let first = true; //通过add接口触发
      //==========================================================
      let doAnimation = function(element, options, func) {
        let width = options.width
        // console.log(width,'width227')

        /*===========这里面定义了动画的算法=========*/
        // 默认动画时长2s
        // element.style.transitionDuration = '400ms';
        // element.style.width =  width + 'px';

        let optall={
          complete:function(){},
          old:false,
          duration: 400,
          easing: undefined,
          queue:"fx",
        }

        let anim=Animation(element, options, optall,func)
        //=================end====================

        //监听动画完结
        //重要，解锁
        //anim.stop
        // element.addEventListener('webkitTransitionEnd', function() {
        // function() {
        //   firing = false;
        //   _fire();
        // }
        //   func()
        // });
      }
      //=========================================================


      //========fire===========
      let _fire = function() {
        //如果动画没有"正在执行（inprogress）"的话
        if (!firing) {
          //取出doAnimation并执行
          let fn = Queue.shift();
          if (fn) {
            //执行动画的锁
            firing = true;
            /*执行doAnimation方法,doAnimation(element, options,function() {firing = false;_fire();})*/
            /*fn的参数就是形参func*/
            //func的作用是用来通知动画执行结束，并继续执行下一个动画
            let func=function() {
              console.log('firing','firing280')
              firing = false;
              _fire();
            }

            fn(func);
          }
        
        }
      }
      //========fire end======

      //=======self=========
      //这里就是jQuery.Callbacks()的方法的简化版
      return self = {
        //增加队列
        //element 目标元素
        //options
        add: function(element, options) {
          //向动画队列中添加 makeAnim触发器
          Queue.push(function(func) {
            doAnimation(element, options, func);
          });
          //一旦queue中有callback的话就触发
          /*该方法只执行一次*/
          if (first && Queue.length) {
            first = false;
            self.fire();
          }
        },
        //触发动画
        //执行_fire触发器
        fire: function() {
          _fire();
        }
      }
      //=======self end======
    })();

    //===================chenQuery的init===================================
    //为chenQuery的fn和prototype原型属性 赋 animate属性
    chenQuery.fn = chenQuery.prototype = {
      //animate方法本质是调用animation.add方法
      //这样又封装一层的目的是因为animation是chenQuery的内部方法
      //不直接暴露给开发者使用
      animate: function(options) {
        animation.add(this.element, options);
        //注意返回的是this,也就是$("#A"),这样就能继续调用animate方法
        // 也就是链式调用
        return this;
      }
    }
    //为chenQuery的fn属性添加init方法
    let init = chenQuery.fn.init = function(selector) {
      // ["#A", "A",groups: undefined,index: 0,input: "#A"]
      let match = rquickExpr.exec(selector);
      //这边默认是只找id的元素
      let element = document.getElementById(match[1])
      //this指chenQuery.fn.init方法
      //为该方法添加element属性
      this.element = element;
      //返回chenQuery.fn.init
      return this;
    }
    //挺绕的，再将init的原型等于chenQuery.fn方法
    init.prototype = chenQuery.fn;
    //===================chenQuery的init end===================================

      //chenQuery本身是一个function(){}
      // chenQuery{
           //init能调用fn，fn能调用init
      //   fn:{
      //     animate:function(){},
      //     init:function(){},
      //     // init.prototype=fn
      //   },
      //   prototype:{
      //     animate:function(){},
      //   }
      // }

    return chenQuery;
  }());


  //==============================
  let A = document.querySelector('#A');
  //在异步调用中，进行同步调用
  //动画是异步的
  A.onclick = function() {
    //就是连续调用animation.add()
    $('#A').animate({
      'width': '500'
    }).animate({
      'width': '300'
    }).animate({
      'width': '1000'
    });
  };



</script>
</body>
</html>
