<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>jQuery的遍历结构设计之节点操作</title>

</head>
<body>
<script src="jQuery.js"></script>
<!--<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>-->
  <button id="test1">append操作</button>

<h2 id="greet">Greetings</h2>
<div class="container">
  <!--<table class="inner">Hello</table>-->
  <!--<table class="inner"></table>-->
  <table id="inner1"></table>
  <!--<div class="inner">Hello</div>-->
  <!--<div class="inner">Goodbye</div>-->
  <div class="inner"></div>
</div>

<script>
  //源码5597行-5586行
  //作用是将传入的参数（dom节点元素、字符串、函数）统一转化为符合要求的DOM节点
  //例:$('.inner').append('<p>Test</p>')
  //nodelist(collections)即$('.inner')
  //args即<p>Test</p>
  function domManip( nodelist, args, callback ) {
    console.log(nodelist,args,'ignored5798')
    //数组深复制成新的数组副本
    //源码是:args = concat.apply( [], args )，这里没有用arguments，而是传参就改了
    let argsArr = []
    argsArr.push(args)
    console.log(argsArr,'args31')
    //l 长度，比如类名为.inner的li有两组,2
    let fragment,
      first,
      node,
      i = 0,
      //l 长度，比如类名为.inner的li有两组,2
      l = nodelist.length,
      iNoClone = l - 1
    //l=2
    if ( l ) {
      console.log(argsArr,nodelist[0].ownerDocument,nodelist,'firstChild40')
      //argsArr:<p>Test</p>
      //nodelist[0].ownerDocument:目标节点所属的文档
      fragment = buildFragment(argsArr,nodelist[0].ownerDocument,false,nodelist );
      first=fragment.firstChild
      console.log(fragment.childNodes,'firstChild42')
      //即<p>Test</p>
      if (first) {
        //=====根据nodelist的长度循环操作========
        for ( ; i < l; i++ ) {
          console.log(node,fragment.childNodes,'childNodes49')
          node = fragment;
          if ( i !== iNoClone ) {
            /*createDocumentFragment创建的元素是一次性的，添加之后再就不能操作了，
            所以需要克隆iNoClone的多个节点*/
            node = jQuery.clone( node, true, true );
          }
          console.log(nodelist[i], node.childNodes,'node50')
          //call(this,param)
          callback.call( nodelist[i], node);
        }
        //====================
      }
    }
    console.log(nodelist,'nodelist58')
    return nodelist
  }

  //源码5724行-5733行
  //额外判断，当在table插入一个tr时，需要先插入tbody，再插入tr
  //this, node
  function manipulationTarget( selector, node ) {
    console.log(node.childNodes,node.firstChild,'node73')
    // 如果是table里面插入行tr
    if ( nodeName( selector, "table" ) &&
      nodeName( node.nodeType !== 11 ? node : node.firstChild, "tr" ) ) {
      return jQuery( selector ).children( "tbody" )[ 0 ] || selector
    }
    return selector
  }

  //源码2843行-2847行
  //判断selector是否是table，返回true/false
  //判断arguments是否是tr，返回true/false
  function nodeName( selector, name ) {
    console.log(selector.nodeName.toLowerCase(),name.toLowerCase(),'name85')
    return selector.nodeName && selector.nodeName.toLowerCase() === name.toLowerCase();
  }

  //源码4857行-4945行
  /*创建文档碎片，原因是一般情况下，我们向DOM中添加新的元素或者节点，DOM会立刻更新。
  如果向DOM添加100个节点，那么就得更新100次，非常浪费浏览器资源。
  解决办法就是：我们可以创建一个文档碎片（documentFragment），
  documentFragment类似于一个小的DOM，在它上面使用innerHTML并在innerHTML上插入多个节点，速度要快于DOM（2-10倍），
  比如：先将新添加的100个节点添加到文档碎片的innerHTML上，再将文档碎片添加到DOM上。*/
  //args, collection[ 0 ].ownerDocument, false, collection
  function buildFragment( arr, context, truefalse, selection ) {
    let elem,tmp, nodes = [], i = 0, l = arr.length
    // createdocumentfragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。
    //相当于document.createDocumentFragment()
    let fragment = context.createDocumentFragment()
    //l=1
    console.log(l,'l87')
    //==============
    for ( ; i < l; i++ ) {
      //"<p>test1</p><div>test2</div>"
      elem = arr[ i ];
      console.log(i,elem,'elem90')
      if ( elem || elem === 0 ) {
        /*创建div是为了处理innerHTML的缺陷（IE会忽略开头的无作用域元素），
          让所有的元素都被div元素给包含起来，包括script，style等无作用域的元素*/
        tmp=fragment.appendChild( context.createElement( "div" ) )
        console.log(elem,'arr114')
        //将修正好的element添加进innerHTML中
        // tmp.innerHTML =jQuery.htmlPrefilter(elem)
        tmp.innerHTML =jQuery.htmlPrefilter('<div><tr>test1</tr></div>')
        console.log(jQuery.htmlPrefilter('<div><tr>test1</tr></div>'),tmp.innerHTML,'elem117')
        jQuery.merge( nodes, tmp.childNodes );
      }
    }
    //================
    // Remove wrapper from fragment
    fragment.textContent = "";
    //需要将i重置为0
    i=0
    console.log(nodes,i,'i100')
    while ( ( elem = nodes[ i++ ] ) ) {
      fragment.appendChild( elem )
    }

    console.log(fragment.childNodes,'fragment105')
    return fragment;
  }

  let ajQuery={}
  jQuery.each({
      //例:'<p>Test</p>'
      //源码6011行-6019行
      // 在被选元素的结尾插入指定内容
      /*append的内部的原理，就是通过创建一个文档碎片，把新增的节点放到文档碎片中，通过文档碎片克隆到到页面上去，目的是效率更高*/
      append: function(nodelist, arguments) {
        //node是由domManip处理得到的文档碎片documentFragment，里面包含要插入的DOM节点
        let callbackOne=function( node ) {
          //this指的就是$("xxx")
          //1:元素节点,11:DocumentFragment,9:document
          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            //table插入tr的额外判断
            //target默认情况是selector，即document.querySelectorAll(".inner")
            let target = manipulationTarget( this, node );
            console.log(target,node.childNodes,'node147')
            //append的本质即使用原生appendChild方法在被选元素内部的结尾插入指定内容
            target.appendChild( node );
          }
        }

        console.log(nodelist,arguments,'this120')
        return domManip( nodelist, arguments, callbackOne );
      },

    },

    function(key, value) {
      ajQuery[key] = function(nodelist, arguments) {
        console.log(nodelist,'nodelist128')
          return  value(nodelist, arguments);
        }
      }
    )




  $('#test1').click(function(){
    let innerArr=document.querySelectorAll(".inner")
    // ajQuery.append(innerArr,'<p>test1</p><div>test2</div>')
    // ajQuery.append(innerArr,'<tr>test1</tr>')
    document.querySelector("#inner1").innerHTML ='<tr>test1</tr>'
    console.log(document.querySelector("#inner1").innerHTML,'inner182')
    
    // ajQuery.append(innerArr,'<table>test1</table>')
    // ajQuery.append(innerArr,"<script>alert('append执行script')")

    // $('.inner').append('<p>test1</p><div>test2</div>');
    // $('.inner').append('<tr>test1</tr>');
    // $('.inner').append($("#greet"));
    // $('.inner').append(document.getElementById("greet"));
    // let a=document.getElementById("greet").innerText
    // $('.inner').append(a);

    /*$.append() 会执行script*/
    // $('.inner').append("<script>alert('append执行script')");


  })


</script>
</body>
</html>
